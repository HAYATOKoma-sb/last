function safeFetchWithRetry(url, options, maxRetries = 3, retryDelayMs = 5000) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = UrlFetchApp.fetch(url, options);
      const json = JSON.parse(response.getContentText());

      if (!json.error || json.error !== 'ratelimited') {
        return json; 
      }

      Logger.log(`â³ Rate limit hit. Retrying ${attempt + 1}/${maxRetries} after ${retryDelayMs / 1000}s...`);
      Utilities.sleep(retryDelayMs);
    } catch (e) {
      Logger.log(`âš ï¸ Fetch ã‚¨ãƒ©ãƒ¼ (è©¦è¡Œ ${attempt + 1}): ${e}`);
      Utilities.sleep(retryDelayMs);
    }
  }

  Logger.log(`âŒ Rate limit exceeded after ${maxRetries} retries: ${url}`);
  return { ok: false, error: 'ratelimited' };
}

function setSlackToken() {
  const token = 'ã“ã“ã«slacktokenã‚’å…¥åŠ›'; 
  PropertiesService.getScriptProperties().setProperty('SLACK_TOKEN', token);
  Logger.log('Slackãƒˆãƒ¼ã‚¯ãƒ³ãŒè¨­å®šã•ã‚Œã¾ã—ãŸã€‚');
}

function setOpenAIApiKey() {
  const key = 'ã“ã“ã«OpenAIkeyã‚’å…¥åŠ›';
  PropertiesService.getScriptProperties().setProperty('OPENAI_API_KEY', key);
  Logger.log('OpenAI APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¾ã—ãŸã€‚');
}

function myFunction() {
  const channelIds = ['ã“ã“ã«slackãƒãƒ£ãƒ³ãƒãƒ«IDã‚’å…¥åŠ›'];
  for (const channelId of channelIds) {
    fetchSlackMessages(channelId);
  }
}

function fetchSlackMessages(channelId, cursor) {
  const props = PropertiesService.getScriptProperties();
  const token = props.getProperty('SLACK_TOKEN');
  let latestTs = parseFloat(props.getProperty(`LATEST_TIMESTAMP_${channelId}`)) || 0;

  if (!token) {
    Logger.log('Slackãƒˆãƒ¼ã‚¯ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚setSlackToken()ã‚’å…ˆã«å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚');
    return;
  }

  let url = `https://slack.com/api/conversations.history?channel=${channelId}&limit=100`;
  if (cursor) url += `&cursor=${encodeURIComponent(cursor)}`;

  const response = UrlFetchApp.fetch(url, {
    method: 'get',
    muteHttpExceptions: true,
    headers: { Authorization: `Bearer ${token}` }
  });

  const json = JSON.parse(response.getContentText());
  if (!json.ok) {
    Logger.log(`Slack API ã‚¨ãƒ©ãƒ¼ (${channelId}): ${json.error}`);
    return;
  }

  const messages = json.messages || [];
  let newestTs = latestTs;
  const messagesToSave = [];

  messages.forEach(msg => {
    const ts = parseFloat(msg.ts);
    if (ts <= latestTs || !msg.text) return;
    if (!msg.user) return;

    const userName = getSlackUserName(token, msg.user);
    const threadReplies = msg.thread_ts ? fetchReplies(token, channelId, msg.thread_ts) : [];

    messagesToSave.push({
      user: userName,
      text: msg.text,
      ts: msg.ts,
      replies: threadReplies
    });

    if (ts > newestTs) newestTs = ts;
  });

  if (messagesToSave.length > 0) {
    saveMessagesToGoogleDoc(channelId, messagesToSave);
  }

  props.setProperty(`LATEST_TIMESTAMP_${channelId}`, newestTs.toString());

  if (json.has_more && json.response_metadata?.next_cursor) {
    props.setProperty(`SLACK_CURSOR_${channelId}`, json.response_metadata.next_cursor);
    props.setProperty('FETCH_CHANNEL', channelId);
    createContinueFetchTrigger();
  } else {
    props.deleteProperty(`SLACK_CURSOR_${channelId}`);
    props.deleteProperty('FETCH_CHANNEL');
    deleteContinueFetchTriggers();
  }
}

function fetchReplies(token, channelId, threadTs) {
  Utilities.sleep(1000);
  const url = `https://slack.com/api/conversations.replies?channel=${channelId}&ts=${threadTs}`;
  const options = {
    method: 'get',
    headers: { Authorization: `Bearer ${token}` },
    muteHttpExceptions: true
  };

  const json = safeFetchWithRetry(url, options);
  if (!json.ok) return [];

  return (json.messages || []).slice(1).map(reply => ({
    user: getSlackUserName(token, reply.user),
    text: reply.text
  }));
}

const userCache = {};

function getSlackUserName(token, userId) {
  if (!userId || !token) {
    Logger.log(`âš ï¸ getSlackUserName: userIdã¾ãŸã¯tokenãŒæœªå®šç¾©ï¼ˆuserId: ${userId}, token: ${token}ï¼‰`);
    return '(ä¸æ˜Žãªãƒ¦ãƒ¼ã‚¶ãƒ¼)';
  }

  if (userCache[userId]) return userCache[userId];

  try {
    Utilities.sleep(1000);
    const url = `https://slack.com/api/users.info?user=${userId}`;
    const options = {
      method: 'get',
      headers: { Authorization: `Bearer ${token}` },
      muteHttpExceptions: true
    };

    const json = safeFetchWithRetry(url, options);
    const name = json.ok ? (json.user.real_name || json.user.name) : '(å–å¾—å¤±æ•—)';
    userCache[userId] = name;
    return name;
  } catch (e) {
    Logger.log(`ãƒ¦ãƒ¼ã‚¶ãƒ¼åå–å¾—ã‚¨ãƒ©ãƒ¼: ${e}`);
    return '(å–å¾—ã‚¨ãƒ©ãƒ¼)';
  }
}

function saveMessagesToGoogleDoc(channelId, messages) {
  const doc = DocumentApp.create(`Slackè©•ä¾¡_${channelId}_${new Date().toISOString()}`);
  const body = doc.getBody();
  const goodSpeakers = new Set();
  const scoreMap = {};

  messages.forEach((msg, i) => {
    const score = callOpenAIAssessment(msg.text);
    body.appendParagraph(`ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ${i + 1}ã€‘`);
    body.appendParagraph(`æŠ•ç¨¿è€…: ${msg.user}`);
    body.appendParagraph(`ã‚¹ã‚³ã‚¢: ${score}/10`);
    body.appendParagraph(msg.text);

    if (!scoreMap[msg.user]) scoreMap[msg.user] = { total: 0, count: 0 };
    scoreMap[msg.user].total += score;
    scoreMap[msg.user].count += 1;

    if (score >= 7) {
      goodSpeakers.add(msg.user);
    }

    if (msg.replies.length > 0) {
      body.appendParagraph('ã€€â†³ è¿”ä¿¡:');
      msg.replies.forEach(reply => {
        const rScore = callOpenAIAssessment(reply.text);
        body.appendParagraph(`ã€€ãƒ»${reply.user}ï¼ˆã‚¹ã‚³ã‚¢: ${rScore}/10ï¼‰: ${reply.text}`);

        if (!scoreMap[reply.user]) scoreMap[reply.user] = { total: 0, count: 0 };
        scoreMap[reply.user].total += rScore;
        scoreMap[reply.user].count += 1;

        if (rScore >= 7) {
          goodSpeakers.add(reply.user);
        }
      });
    }

    body.appendParagraph('');
  });

  if (goodSpeakers.size > 0) {
    body.appendParagraph('======');
    body.appendParagraph('ðŸŒŸ è‰¯ã„ç™ºè¨€è€…ä¸€è¦§ ðŸŒŸ');
    Array.from(goodSpeakers).forEach(name => body.appendParagraph(`ãƒ»${name}`));
  }

  const ranking = Object.entries(scoreMap)
    .map(([user, { total, count }]) => ({ user, avg: total / count, total, count }))
    .filter(u => u.count >= 2)
    .sort((a, b) => b.avg - a.avg);

  if (ranking.length > 0) {
    body.appendParagraph('======');
    body.appendParagraph('ðŸ† å¹³å‡ã‚¹ã‚³ã‚¢ãƒ©ãƒ³ã‚­ãƒ³ã‚°ï¼ˆä¸Šä½ï¼‰ðŸ†');
    ranking.forEach((entry, index) => {
      body.appendParagraph(`${index + 1}. ${entry.user} - å¹³å‡ã‚¹ã‚³ã‚¢: ${entry.avg.toFixed(2)} (${entry.count}ä»¶)`);
    });
  }

  doc.saveAndClose();
  Logger.log(`AIè©•ä¾¡ä»˜ããƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆä½œæˆï¼ˆ${channelId}ï¼‰: ${doc.getUrl()}`);
}

function callOpenAIAssessment(text) {
  const apiKey = PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY');
  if (!apiKey) {
    Logger.log('OpenAI APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
    return 0;
  }

  const prompt = `
ä»¥ä¸‹ã®Slackã®æŠ•ç¨¿ãŒã€Œä»–ã®äººã®å­¦ã³ã‚„ç†è§£ã«ã©ã‚Œã ã‘è²¢çŒ®ã™ã‚‹ã‹ã€ã‚’10ç‚¹æº€ç‚¹ã§è©•ä¾¡ã—ã¦ãã ã•ã„ã€‚
æ•°å€¤ã®ã¿ï¼ˆ1ã€œ10ã®æ•´æ•°ï¼‰ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚ä»–ã®æ–‡ç« ã¯ä¸€åˆ‡ä¸è¦ã§ã™ã€‚

æŠ•ç¨¿å†…å®¹: "${text}"
`;

  const payload = {
    model: "gpt-4.1",
    messages: [
      { role: "system", content: "ã‚ãªãŸã¯SlackæŠ•ç¨¿ã‚’æ•™è‚²çš„ä¾¡å€¤ã®è¦³ç‚¹ã‹ã‚‰è©•ä¾¡ã™ã‚‹AIã§ã™ã€‚" },
      { role: "user", content: prompt }
    ],
    temperature: 0.2
  };

  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: `Bearer ${apiKey}` },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch('https://api.openai.com/v1/chat/completions', options);
    const json = JSON.parse(response.getContentText());
    const textResponse = json.choices?.[0]?.message?.content?.trim();

    if (!textResponse) {
      Logger.log(`OpenAI å¿œç­”ãŒä¸æ­£ã§ã™: ${JSON.stringify(json)}`);
      return 0;
    }

    const match = textResponse.match(/\b(10|[1-9])\b/);
    return match ? parseInt(match[1], 10) : 0;
  } catch (e) {
    Logger.log(`OpenAI APIã‚¨ãƒ©ãƒ¼: ${e}`);
    return 0;
  }
}

function createContinueFetchTrigger() {
  const allTriggers = ScriptApp.getProjectTriggers();
  allTriggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'continueFetch') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  ScriptApp.newTrigger('continueFetch').timeBased().after(30 * 1000).create();
}

function deleteContinueFetchTriggers() {
  const allTriggers = ScriptApp.getProjectTriggers();
  allTriggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'continueFetch') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
}
function deleteAllTriggers() {
  const allTriggers = ScriptApp.getProjectTriggers();
  allTriggers.forEach(trigger => {
    ScriptApp.deleteTrigger(trigger);
  });
}
function createDailyTrigger() {
  const triggers = ScriptApp.getProjectTriggers();
  for (let t of triggers) {
    if (t.getHandlerFunction() === 'myFunction') {
      ScriptApp.deleteTrigger(t);
    }
  }
  ScriptApp.newTrigger('myFunction')
    .timeBased()
    .everyDays(1)
    .atHour(0) 
    .create();
}
